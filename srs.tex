\documentclass[a4paper,12pt]{article}

\usepackage[margin=2cm]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{array}
\usepackage{hyperref}
\usepackage[all]{hypcap}
\usepackage{listings}
\lstdefinestyle{TerminalStyle}{
  language=bash,
  basicstyle=\small\sffamily,
  numbers=left,
  numberstyle=\tiny,
  numbersep=3pt,
  frame=tb,
  columns=fullflexible,
  linewidth=0.9\linewidth,
  xleftmargin=0.1\linewidth
}
\lstdefinestyle{HtmlStyle}{
  language=html,
  basicstyle=\small\sffamily,
  numbers=left,
  numberstyle=\tiny,
  numbersep=3pt,
  frame=tb,
  columns=fullflexible,
  linewidth=0.9\linewidth,
  xleftmargin=0.1\linewidth
}
\lstdefinestyle{OutputStyle}{
  language=html,
  basicstyle=\small\sffamily,
  frame=tb,
  columns=fullflexible,
  linewidth=0.9\linewidth,
  xleftmargin=0.1\linewidth
}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

\title{\includegraphics[width=12cm]{Eeufeeslogo.jpg} \\
       Department of Computer Science \\
       University of Pretoria \\
       \vspace{0.5cm}
       COS730 Software Engineering \\
       \vspace{0.5cm}
       \begin{large} \textbf{Software Requirement Specifications}\end{large}}

\date{07 March 2018} 
\author{	JM Bondjobo		13232852 \\
		Martha Mohlala		10353403\\
		D Jansen van Vuuren	18364412\\
		 KJ Muranga         13278012        \\
		 RT Mabaso          18296272
}

\begin{document}
\maketitle
\thispagestyle{empty}
\clearpage

\newpage
\pagenumbering{roman}
\thispagestyle{empty}
\tableofcontents
\clearpage

\newpage
\pagenumbering{arabic}

\section {Introduction}
This section gives a scope description of the benchmark service system. Also, the purpose for this document is described and a list of abbreviations and definitions is provided.
\subsection{Purpose}
The goal of this document is to give a detailed description of the  benchmarking service. It will explain the purpose and features of the system, the interfaces of the system, what the system will do and the constraints under which it must operate.


\subsection{Scope}
The benchmarking service will accept a user's source code and measure its performance in terms of CPU time, elapsed time, memory usage, power consumption, temperature, and others.The user's source code could be either an algorithm or a data structure, and the system should give the user a choice of which programming languages their source code can be implemented in. The service should be provided by executing the requested benchmarks on isolated machines where the side-effects that are not a concern of the specified benchmark are minimized.

The system will be used as an integral part of research related to the development of new algorithms and techniques as well as the refinement and optimisation of existing operations. It can also be used to as a teaching tool for students to review the notions of space and time complexity.



\subsection{Definitions, Acronyms and Abbreviations}
\begin{center}
\begin{tabular}{ |p{5cm}|p{10cm}| } 
\hline
Term & Definition \\ 
\hline
User & Individual who uses the benchmarking system. \\ 
\hline
Software Requirements Specification & A document that completely describes all of the functions of a proposed system and the constraints under which it must operate. For example, this document. \\ 
\hline
Benchmark & Evaluate (something) by comparison with a standard. \\
\hline
RAM & Random Access Memory  \\
\hline
HTTP & HyperText Transfer Protocol \\
\hline
TCP & Transmission Control Protocol\\
\hline
\end{tabular}
\end{center}

\subsection{References}
IEEE. IEEE Std 830-1998 IEEE Recommended Practice for Software Requirements Specifications. IEEE Computer Society, 1998

\subsection{Overview}
The remainder of this document consists of two chapters. In the second chapter, the Overall Description section which gives a description of the system's functionality. It describes the informal requirements and is used to establish a context for the technical requirements specification in the next chapter.

In the third chapter you will find the Specific Requirements section which gives a detailed description of the benchmarking service. It describes in technical terms the details of the functionality of the system.

\section{Overall Description}
\subsection{Product Perspective}

\subsubsection{System Interfaces}
The system will provide a web interface for users to request and specify the benchmarking services they need. The system interface is depicted as below:\\
\includegraphics[width=12cm]{SI.jpeg}
\subsubsection{User Interfaces}
The system will have a user interface where the user will interact with the system by requesting some services and getting a response from the system done at the back-end. This is the front-end part of the system that the client/user will be interacting with. The benchmark tool will follow basic Windows style and functionality conventions. The interface will have a menu where the user will be able to input their variables, a log button on the menu to see what services were done on the pc and by who, a section where the user can track progression of the execution and retrieve any notifications pushed by the benchmark tool and a quick access button to terminate the benchmarking process if the user choose so. 
\subsubsection{Hardware Interfaces}
The system will run a computer that has Windows 7 and higher and that has at least 100 MB of free space on the hard drive and 1 GB of Ram. The computer used must be an isolated machine where the benchmarking service will be done in order to reduce/ minimize the side effects of others programs running simultaneously. The system does not write information directly to the user's computer. But instead uses a database which is located on a network server. The user's computer transfers and receives data using basic networking protocols like HTTP. All systems' information is stored in the server's database which stores the data on the server's disk reason being if the system runs out of memory or fails during benchmarking the previously gathered information remains on the server's database.
\subsubsection{Software Interfaces}
The system requires a properly configured version of Windows 7 or later to run the application. The system's server can either be Windows or Linux but must have a MySQL database properly installed and configured. The software interface will be web based, therefore must have Microsoft .NET Framework 1.1 or greater installed and for the designing of the benchmarking that can be done using Adobe XD.

\subsubsection{Communication Interfaces}
The benchmarking system will have a network server that is web-based. The server exists to retrieve information from the database
and compute the services in terms of the benchmark metrics provided. The web interface will also query the database for the historical computations of the benchmark metrics. The HTTP server will be used to send the requests from the web interface to
the benchmarking system. The web application will support all types of browsers.
\subsubsection{Memory}
The system will not use memory less than 100 MB of the hard drive and 1 GB of RAM as described on the hardware interface.
\subsubsection{Operations}
The user will initiate the request for benchmarking services and wait for response. The response might take a while as the system is required to do computation and comparison between two inputs. The user will have an option of inputting algorithm or data structure and the input will be validated to check if it is algorithm or data structure. The system will also allow the user to store all the computation and comparison results to the database as historical data to avoid computing the same request many times,and also for recovery. 
\subsubsection{Site Adaptation Requirements}
The program or tool must able to view and compile code. It must measure CPU (Central Processing Unit) performance, memory usage (RAM, Random Access Memory), temperature, power consumption and a lot of other variables.
It should also ideally be able to accept and handle any modern coding languages such as Java, C\#, C++ etc. The program must also be a web-application that can compile code and test for its runtime attributes. 
The user must select their programming language and then input the code. The program then compiles the code and give feedback on power usage, temperature difference etc. This will all be done in a web-application.

\subsection{Product Functions}
The software will perform a list of functions like:
\begin{itemize}
\item Check what code is written.
\item Compile code
\item Minimize main application concern
\item Calculate memory usage
\item Calculate temperature difference
\item Calculate power consumption
\item Calculate CPU usage
\item Give feedback.
\item User must be able to keep feedback (download)
\end{itemize}
	
These functions must be executed and the correct feedback must be given. For instance, when the user's code is compiled, the calculation must not measure performance changes to the program, but rather only to the user's code. 
The process of the functions are as follows:
\begin{itemize}
\item User selects programming language
\item User inputs their code.
\item Program compiles code.
\item Measure performance and hold information
\item If code did not have any errors
\item Give performance feedback
\item If code did have errors
\item Give correct feedback
\end{itemize}



\subsection{User Characteristics}
An average user does not even need to have a programming background. If the user needs to test the performance of code and give the feedback back to the developer, they can. They can simply copy the code into the program and get the results, if there aren't any errors in the code that they submitted. One of the goals of the application is to give feedback in a very user friendly manner, so that they do not need any knowing of how coding works to use the information. 

Graphs can be created to give users an even better understanding of how the application measures performance. These graphs can then be downloaded and exported to an excel document or PDF. 

\subsection{Constraints}
Limitations to developer options can include the following:
\begin{itemize}
\item Programming knowledge (Being able to only compile code that the developers know of).
\item Parallel operation (Measuring one program inside another program).
\item Control function (Test whether user code will "break" our program).
\item If user's device is to slow (Hinder measuring process may result in inaccurate results).
\end{itemize}

\subsection{Assumptions and Dependencies}
To make it possible to reach this benchmark tool online it is assumed that the tool might be deployed to an off site computer such as cloud. A possible solution would be AWS, Amazon's cloud based solution. Dependencies includes but are not limited to JDK 1.8 and Oracle drivers as well as an inbound and outbound network rules to allow users to communicate with the program and also to allow the program to connect to external resources. There will also be an dependency toward an Oracle database as this would be where sample data would be stored. The application would also need a container such as Web-logic to preside in. This would make it easier to not only gain access to the benchmark tool but also to obtain the necessary statistics to display to the user. 

\section{Specific Requirements}

\subsection{External Interface Requirements}
The system that needs to be developed is a coding benchmarking tool. The system shall perform a benchmark on the code the user input. The benchmark will obtain from data from an Oracle database execute the code and then return statistics about the resources the code use when it was executed. The system will return statistics like
Hardware interface
Input
\begin{itemize}
\item The amount of memory made available to execute the code.
\item The amount of CPU cores made available to execute the code. 
\item The amount of threads the application is allowed to use.
\end{itemize}
Output
\begin{itemize}
\item The CPU usage that the program used while executing excluding the usage the benchmark tool used itself
\item The temperature levels the CPU reached while executing the user's program. It would be in a Celsius and Fahrenheit format
\item The amount of CPU cores used to execute the program.
\item The CPU that is used to execute the program. 
\item The amount of threads that might have been used to execute the program. 
\item The amount of memory the program used while executing excluding the usage the benchmark tool used it self. The format would be in byte format such as MB or KB
\item The amount of memory that was made available for the program to be executed. The format would be in byte format such as MB or KB
\end{itemize}
Software interface
Input:
\begin{itemize}
\item The code the user wants to execute.
\item The language type the user wants to execute.
\item Any external  data (if applicable) that is needed to execute the program.
\item A time limit (if any) to execute the program
\end{itemize}
Output
\begin{itemize}
\item Will show statistics about the hardware usage as specified above. The statistics might be presented in different ways such as graphs or through the use of progress bars. 
\item The software should also show any relevant statistics that the network used. 
\item If the program was executed on other hardware, this statistics would be used to also compare previous performances the program achieved on that benchmark
\item The overall time used to execute the program would be displayed.
\item If there are any sub sections to the code that is used while executing this would be timed on its owned and also displayed.
\item The time it took to make any external connections and the time it kept the connections open would also be displayed.  
\end{itemize}
Communication Interface
Input:
\begin{itemize}
\item A TCP connection to any external resource the program the user wants to execute might need to achieve its goal (A connection to an external database or a container such as Web-logic) 
\item Local connections to any resources needed such as retrieving local test data from Oracle
\end{itemize}
Output:
\begin{itemize}
\item The network usage if the program made any external connections. The format would be in a byte formate accumulated over time such as GB, MB or KB.
\item The average speed the network used toward the external resource as well as the top speed it reached. The format of this usage would possible be in bit per second format such as GB/s, MB/s or KB/s 
\item The local connection usage the program used. The format would be in a byte formate accumulated over time such as GB, MB or KB.
\item The average speed local connections used as well as the top speed The format of this usage would possible be in byte per second format such as GB/s, MB/s or KB/s 
\end{itemize}


\subsection{Functional Requirements}
 The system will provide the user an interface to execute an application of their choosing. Input checks would include to see if the format of the input is correct such as a number followed by MB or Mb for the use of limits on memory. Number only input blocks. A valid language so that the benchmark tool would be able to know how to execute the program. 
 
 The requirements to follow are:
\begin{enumerate}
\item The benchmark tool must validate any input given by the user
\item A connection to the local database would be made
\item The benchmark tool must start executing after request initiation
\item During execution the benchmark tool must accumulate the necessary statistics that would display in the output
\item Also if there are any external connections made by the application. It must be done so during execution. 
\item Any limits must be kept in mind and if the program surpasses the limit specified the user must be notified but execution should continue if possible.
\item  If the program throws an exception but it did not lead the program to crash the benchmark tool must notify the user and continue execution.
\item If a situation occurred while the program was executed all relevant statistics should be displayed as well as the problem that lead to why execution was not successful
\item If no unforeseen situations occurred and the program executed successfully, the statistics should be displayed
\item The statistics should be logged and stored in the database. This is to record history and to allow the user to gain access to it in a later stage.
\end{enumerate}

Abnormal situations that might occur are:
\begin{itemize}
\item Not obtaining a connection to the local database. 
\item An exception thrown by the benchmark tool. In cases such as
\begin{itemize}
\item Not being able to execute the program for unknown reasons 
\item Unable to obtain statistics while performing the execution operation
\item Unable to obtain any external connections the program wanted to create
\item The program crashed 
\item An internal exception occurred in the benchmark tool itself
\end{itemize}
 
\end{itemize}
Most input output relationships are centred around the software as it takes the limitations the user specified as input as well as code but network interface would communicate to the software to deliver its statistics as well as the hardware. 

\subsection{Performance Requirements}
The system shall respond to user input in few minutes, if it takes too long than expected, a progress indicator shall be display to notify the user.
If the system loses the connection to internet, an error message or pop-up message will be display to inform the user.
The system should be able to handle reasonable users without inconsistency.
\subsection{Design Constraints}
The hard drive free space must be at least 100 MB and 1 GB ram.
\subsection{Software System Attributes}
\subsubsection{Reliability}
The system should work reliably, with automatic backup and recovery features. In case of unexpected operating system error or shut-down, the unsaved data should be recovered without loss. The user will be able to save all the computation and comparison results to the database.
\subsubsection{Availability}
The system will be available when it is used.The internet connection should be available to use the system.
\subsubsection{ Security }
The system should be access only by the authenticated users. The users credential should be encrypted.
\subsubsection{Maintainability}
All code shall be well documented. Each function will have comment so that it can be easy for the developer who wishes to edit it and for the person who is in charge for maintenance.
\subsubsection{Portability}
The system should support windows 7 and higher.
\subsubsection{Usability}
 The GUI should be easy to learn and use by users. Either user has programming background or not the system should be user friendly. A built-in help feature should be available in all pages, to guide users how the system work and how to use the system.

\newpage
\clearpage
\addcontentsline{toc}{section}{References}

\end{document}
